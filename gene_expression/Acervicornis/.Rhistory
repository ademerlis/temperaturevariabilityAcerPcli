CBASS_tank == "8" ~ "28")) %>%
mutate(slowburn= case_when(slowburn_heatstress_tank == "7" ~ "ambient",
TRUE ~ "heatstress_32")) -> slowburn_metadata
slowburn_metadata %>%
filter(slowburn == "heatstress_32") %>%
filter(Removed_Date >= "2022-06-25" | is.na(Removed_Date)) %>%
mutate(Removed_Date = ymd(Removed_Date)) %>%
mutate(mortality_date = ymd(mortality_date)) %>%
mutate(end_date = coalesce(Removed_Date, mortality_date)) %>% #if removed_date is NA, then look and use the date from mortality date
mutate(start_date="2022-06-25") %>%
mutate(start_date = ymd(start_date)) %>%
mutate(days_to_removed = end_date - start_date) %>%
select(Species, ID, Colony, Treatment, CBASS_temp, slowburn, days_to_removed) -> slowburn_summary_data
str(slowburn_summary_data)
#make factors: Colony, Puck, Tank, Treatment, Species
slowburn_summary_data %>%
mutate_at(vars(Species, ID, Colony, Treatment, CBASS_temp), factor) %>%
mutate(days_to_removed = as.numeric(days_to_removed)) -> slowburn_summary_data
treat_model <- lm(days_to_removed ~ Treatment*Species*CBASS_temp + Colony, data = slowburn_summary_data)
treat_model_metrics <- augment(treat_model)
plot(treat_model)
# assess normality of residuals using Shapiro-Wilk test
shapiro_test(treat_model_metrics$.resid) # not significant
# assess homogeneity of variances using Levene's Test
levene_test(.resid ~ Treatment*Species*CBASS_temp, data = treat_model_metrics) #not significant
summary(aov(days_to_removed ~ Treatment*Species*CBASS_temp, data = slowburn_summary_data))
slowburn_metadata %>%
filter(slowburn == "heatstress_32") %>%
filter(Removed_Date >= "2022-06-25") %>%
mutate(start_date="2022-06-25") %>%
mutate(start_date = ymd(start_date)) %>%
mutate(Removed_Date = ymd(Removed_Date)) %>%
mutate(days_to_removed = Removed_Date - start_date) %>%
mutate(days_to_removed = as.numeric(days_to_removed)) %>%
group_by(Species, Treatment) %>%
summarise(mean=mean(days_to_removed), sd = sd(days_to_removed)) %>%
as.data.frame()
treat_model <- lm(days_to_removed ~ Treatment*Species*Colony, data = slowburn_summary_data)
treat_model_metrics <- augment(treat_model)
plot(treat_model)
# assess normality of residuals using Shapiro-Wilk test
shapiro_test(treat_model_metrics$.resid) # significant
# assess homogeneity of variances using Levene's Test
levene_test(.resid ~ Treatment*Species, data = treat_model_metrics) #not significant
#make interaction term
slowburn_summary_data$Species_Treatment_Colony <- interaction(slowburn_summary_data$Species, slowburn_summary_data$Treatment, slowburn_summary_data$Colony)
#run Welch's anova
oneway.test(days_to_removed ~ Species_Treatment_Colony, data = slowburn_summary_data, var.equal = FALSE) #significant
slowburn_summary_data
slowburn_summary_data
#what are the sample sizes?
slowburn_summary_data %>%
group_by(Species, Colony, Treatment, slowburn) %>%
summarise(count = n())
#what are the sample sizes?
slowburn_summary_data %>%
drop_na() %>%
group_by(Species, Colony, Treatment, slowburn) %>%
summarise(count = n())
#what are the sample sizes?
slowburn_summary_data %>%
drop_na() %>%
group_by(Species, Colony, Treatment) %>%
summarise(count = n())
slowburn_summary_data
#run Welch's anova
oneway.test(days_to_removed ~ Species_Treatment_Colony, data = slowburn_summary_data, var.equal = FALSE) #significant
library(tidyverse)
library(janitor)
library(rstatix)
library(cowplot)
library(plotrix)
metadata <- readxl::read_xlsx("../metadata.xlsx", sheet = "tidy_data")
str(metadata) #295 corals
# metadata %>%
#   filter(!Removed_Date == "unknown") -> metadata #244 corals...
metadata$Removed_Date <- as.numeric(metadata$Removed_Date)
metadata$Removed_Date <- as.Date(metadata$Removed_Date, origin = "1899-12-30")
metadata$mortality_date <- as.numeric(metadata$mortality_date)
metadata$mortality_date <- as.Date(metadata$mortality_date, origin = "1899-12-30")
metadata %>%
mutate(CBASS_temp = case_when(CBASS_tank == "1" ~ "36",
CBASS_tank == "2" ~ "37",
CBASS_tank == "3" ~ "32",
CBASS_tank == "4" ~ "33",
CBASS_tank == "5" ~ "35",
CBASS_tank == "6" ~ "30",
CBASS_tank == "7" ~ "34",
CBASS_tank == "8" ~ "28")) -> tidy_metadata
tidy_metadata %>%
filter(Removed_Date < "2022-05-20") %>%
arrange(desc(Removed_Date))
#April 26 was the last coral reported with a mortality date until the slow burn heat stress started. So have April 26 be the cut-off point for CBASS mortality plots.
ggplot(tidy_metadata, aes(x=Removed_Date, fill = Treatment)) +
geom_bar() +
facet_wrap(~Species)
ggplot(tidy_metadata, aes(x=mortality_date, fill = Treatment)) +
geom_bar() +
facet_wrap(~Species)
CBASS_mortality <- tidy_metadata %>%
dplyr::filter(Removed_Date >= "2022-04-20" & Removed_Date <= "2022-04-26")
#for this time period, Removed_Date and mortality_date match up so there's no need to use the coalesce function
CBASS_mortality %>%
mutate(Reason_removed = case_when(Reason_removed == "dead" ~ "RTL",
Reason_removed == "post-CBASS RTL" ~ "RTL",
Reason_removed == "RTL" ~ "RTL")) %>%
drop_na(Species, Treatment) %>%
group_by(Species, Treatment) %>%
summarize(count_RTL = n()) -> RTL_species_treatment_count
CBASS_mortality %>%
mutate(Reason_removed = case_when(Reason_removed == "dead" ~ "RTL",
Reason_removed == "post-CBASS RTL" ~ "RTL",
Reason_removed == "RTL" ~ "RTL")) %>%
drop_na(Species, Treatment) %>%
group_by(Species, Treatment, CBASS_temp) %>%
summarize(count_RTL = n()) -> RTL_species_treatment_CBASStemps
tidy_metadata %>%
dplyr::filter(!Removed_Date <= "2022-04-20" | is.na(Removed_Date)) %>% #remove everything that was removed before CBASS so you only account for RTL due to CBASS
group_by(Species, Treatment) %>%
summarize(count_total = n()) %>%
full_join(., RTL_species_treatment_count) %>%
mutate(count_survived = count_total-count_RTL) %>%
mutate(proportion_survived = count_survived/count_total) %>%
mutate(proportion_RTL = 1-proportion_survived)
library(tidyverse)
library(plotrix)
library(ggplot2)
library(tidyr)
library(goseq)
all_genes <- read_delim("GO-MWU/Acropora_iso2go.tab")
View(all_genes)
all_genes <- read_delim("GO-MWU/Acropora_iso2go.tab", header=TRUE)
all_genes <- read_delim("GO-MWU/Acropora_iso2go.tab")
new_row <- as.data.frame(t(colnames(all_genes)), stringsAsFactors = FALSE)
View(new_row)
View(all_genes)
View(all_genes)
all_genes <- rbind(new_row, all_genes)
all_genes_new <- rbind(new_row, all_genes)
new_row
colnames(all_genes)=c("Gene", "GO_term")
View(all_genes)
all_genes_new <- rbind(new_row, all_genes)
colnames(new_row)=c("Gene", "GO_term")
all_genes_new <- rbind(new_row, all_genes)
View(all_genes_new)
View(all_genes)
View(all_genes_new)
View(new_row)
View(all_genes_new)
goslim <- read.csv("GO-GOslim.csv")
goslim <- goslim %>% dplyr::select(-term)
#generate list of all genes identified and background list for GO enrichment analysis
all_genes <- read_delim("GO-MWU/Acropora_iso2go.tab")
new_row <- as.data.frame(t(colnames(all_genes)), stringsAsFactors = FALSE)
colnames(all_genes)=c("gene", "GO_IDs")
colnames(new_row)=c("gene", "GO_IDs")
all_genes_new <- rbind(new_row, all_genes)
goslim <- read.csv("GO-GOslim.csv")
goslim <- goslim %>% dplyr::select(-term)
goslim
##### Writing goenrich function #####
goenrich <- function(filename,
identifier){
DMG <- as.character(filename$gene) #set the enrichment test list
DMG.vector <-c(t(DMG)) #change to vectors
gene.vector=as.integer(ALL.vector%in%DMG.vector) #Construct new vector with 1 for DEG and 0 for others
names(gene.vector)=ALL.vector #set names
DEG.pwf<-nullp(gene.vector, ID.vector, bias.data=LENGTH.vector) #weight vector by length of gene
#Find enriched GO terms
GO.wall<-goseq(DEG.pwf, ID.vector, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GO <- GO.wall[order(GO.wall$over_represented_pvalue),]
colnames(GO)[1] <- "GO_ID"
#GOslim
GO.slim <- merge(GO, goslim, by = "GO_ID")
GO.slim <- GO.slim[!duplicated(GO.slim$GO_ID), ]
#Filtering for p > 0.05
filename_sig.GO <- GO.slim %>%
dplyr::filter(over_represented_pvalue <0.05) %>%
arrange(., ontology, term, over_represented_pvalue)
#write.csv(sig.GO , file = "output/WGBS/DMG/sig.GO.OxTxL.csv")
#Formatting sig gene file with a goterm per row
split <- strsplit(as.character(filename$GO_IDs), "; ")
split2 <- data.frame(v1 = rep.int(filename$gene, sapply(split, length)), v2 = unlist(split))
colnames(split2) <- c("gene", "GO_IDs")
filename2 <- filename %>% dplyr::select(-GO_IDs, -GO_Name, -Length)
filename_GO <- merge(split2, filename2, by = "gene")
colnames(filename_GO)[2] <- "GO_ID"
# Merge sig meth genes with goslim
filename_GOslim <- merge(filename_GO, filename_sig.GO, by = "GO_ID", all = TRUE)
write.csv(filename_GOslim)
return(filename_GOslim)
}
TreatedvUntreated_DGEs <- read.csv("results_csv/TreatedvsUntreated_annotatedDGEs.csv")
TreatedvUntreated_DGEs
goenrich(TreatedvInitial_DGEs, TreatedvInitial)
goenrich(TreatedvUntreated_DGEs, TreatedvUntreated)
# Vector with all genes after filtering
ALL.vector <-c(t(all_genes_new$gene))
ID.vector <- all_genes_new$gene
LENGTH.vector <-all_genes_new$Length
goenrich(TreatedvUntreated_DGEs, TreatedvUntreated)
TreatedvUntreated_DGEs
all_genes_new
LENGTH.vector <-length(all_genes_new)
LENGTH.vector
LENGTH.vector <-length(t(all_genes_new))
t(all_genes_new$gene)
goenrich(TreatedvUntreated_DGEs, TreatedvUntreated)
library(tidyverse)
library(WGCNA)
library(flashClust)
library(ape)
options(stringsAsFactors=FALSE)
allowWGCNAThreads()
lnames=load("RData_files/data4wgcna.RData")
setwd("~/OneDrive - University of Miami/GitHub/Ch2_temperaturevariability2023/gene_expression/Acervicornis")
lnames=load("RData_files/data4wgcna.RData")
lnames # "vsd.wg"  "design" # log-transformed variance-stabilized gene expression, and table or experimental conditions
datt=t(vsd.wg)
ncol(datt) #15526
nrow(datt) #44
head(design)
str(design)
colnames(vsd.wg)
all.equal(colnames(vsd.wg), rownames(design)) #FALSE
#change rownames to match colnames
rownames(design) <- colnames(vsd.wg)
head(design)
all.equal(colnames(vsd.wg), rownames(design)) #TRUE
rownames(datt)
#change treatment to be binary (0 = FALSE, 1 = TRUE)
Initial = as.numeric(design$Treatment=="Initial")
Untreated = as.numeric(design$Treatment == "Untreated")
Treated = as.numeric(design$Treatment == "Treated")
traits <- data.frame(cbind(Initial, Untreated, Treated))
rownames(traits) <- rownames(design)
traits
traits %>%
rownames_to_column() %>%
mutate(rowname = str_extract(rowname, "^[^_]*")) %>%
separate(rowname, into = c("Species", "ID"), sep = "\\.") %>%
mutate(Species = "Acropora cervicornis") %>%
mutate(ID = as.double(ID)) -> traits
traits
days_to_removed <- read_csv("physiotraits_for_WGCNA/days_to_removed.csv")
days_to_removed %>%
dplyr::select(!c("Colony", "Treatment")) %>%
filter(Species == "Acropora cervicornis") -> days_to_removed
phagocytosis <- read_csv("physiotraits_for_WGCNA/relative_immune_activity.csv")
phagocytosis %>%
dplyr::select(!c("Tank", "Genotype", "Treatment", "num_days", "mean_replicate_percent_perID", "mean_untreated_day0_genet")) %>%
filter(Species == "Acer") %>%
mutate(Species = "Acropora cervicornis") %>%
mutate(ID = gsub("[AP]", "", ID)) %>%
mutate(ID = as.double(ID)) -> phagocytosis
Rscore <- read_csv("physiotraits_for_WGCNA/treatment_Rscore.csv")
Rscore %>%
filter(Species == "Acropora cervicornis") %>%
dplyr::select(!c("Colony", "Treatment")) %>%
mutate(ID = as.double(ID)) -> Rscore
CBASS_fvfm <- read_csv("physiotraits_for_WGCNA/cbass_fvfm_forwgcna.csv")
CBASS_fvfm %>%
filter(Species == "Acervicornis") %>%
mutate(Species = "Acropora cervicornis") %>%
dplyr::rename(ID = Puck) %>%
mutate(ID = gsub("[AP]", "", ID)) %>%
mutate(ID = as.double(ID)) %>%
dplyr::select(!c("Colony", "Treatment")) -> CBASS_fvfm
full_join(traits, days_to_removed, by = c("Species", "ID")) %>%
full_join(., phagocytosis) %>%
full_join(., Rscore) %>%
full_join(., CBASS_fvfm) %>%
drop_na(Initial) %>%
dplyr::select(!c("Species", "ID")) -> traits_withphysio
# traits_withphysio %>%
#   select(!c(1)) -> traits_withphysio
#### OUTLIER DETECTION ####
# identifies outlier genes
gsg = goodSamplesGenes(datt, verbose = 3);
gsg$allOK #if TRUE, no outlier genes
#TRUE!
# calculates mean expression per array, then the number of missing values per array
meanExpressionByArray=apply( datt,1,mean, na.rm=T)
NumberMissingByArray=apply( is.na(data.frame(datt)),1, sum)
NumberMissingByArray
# sample dendrogram and trait heat map showing outliers
A=adjacency(t(datt),type="signed")                 #SELECT SIGNED OR UNSIGNED HERE
# run from the line below to the save command
s.th=19 # re-specify according to previous section
adjacency = adjacency(datt, power = s.th,type="signed");
TOM = TOMsimilarity(adjacency,TOMType="signed");
rm(adjacency) #for memory space
dissTOM = 1-TOM
rm(TOM)
# Call the hierarchical clustering function
geneTree = flashClust(as.dist(dissTOM), method = "average")
plot(geneTree, xlab="", sub="", main="Gene Clustering on TOM-based dissimilarity", labels= FALSE,hang=0.04)
minModuleSize = 30;
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Calculate eigengenes
MEList = moduleEigengenes(datt, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
METree = flashClust(as.dist(MEDiss), method = "average");
save(dynamicMods,dynamicColors,MEs,METree,geneTree,file="1stPassModules.RData")
MEDissThres = 0.4 # in the first pass, set this to 0 - no merging (we want to see the module-traits heatmap first, then decide which modules are telling us the same story and better be merged)
# Call an automatic merging function
merge = mergeCloseModules(datt, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
# Rename to moduleColors
moduleColors = mergedColors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
MEDiss = 1-cor(MEs);
# how many genes in each module?
table(moduleColors)
# Save module colors and labels for use in subsequent parts
save(MEs, geneTree, moduleLabels, moduleColors, file = "networkdata_signed.RData")
# Define numbers of genes and samples
nGenes = ncol(datt); #15526
nGenes
nSamples = nrow(datt); #43
Recalculate
nSamples
# Remove outlying samples from expression and trait data
remove.samples= Z.k<thresholdZ.k | is.na(Z.k)
# standardized connectivity
Z.k=scale(k)
# this calculates the whole network connectivity
k=as.numeric(apply(A,2,sum))-1
# standardized connectivity
Z.k=scale(k)
thresholdZ.k=-2.5 # often -2.5
outlierColor=ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
# Convert traits to a color representation where red indicates high values
traitColors=data.frame(numbers2colors(traits_withphysio,signed=TRUE))
dimnames(traitColors)[[2]]=paste(names(traits_withphysio))
datColors=data.frame(outlierC=outlierColor,traitColors)
plotDendroAndColors(sampleTree,groupLabels=names(datColors), colors=datColors,main="Sample dendrogram and trait heatmap")
# Remove outlying samples from expression and trait data
remove.samples= Z.k<thresholdZ.k | is.na(Z.k)
datt=datt[!remove.samples,]
traits_withphysio=traits_withphysio[!remove.samples,] #1 sample removed
str(datt) #43
str(traits_withphysio) #43
write.csv(traits, file="traits.csv")
write.csv(traits_withphysio, file="traits_withphysio.csv")
save(datt,traits,file="wgcnaData.RData")
#datt=t(vsd.wg)
str(datt) #43
# Try different betas ("soft threshold") - power factor for calling connections between genes
powers = c(seq(from = 2, to=26, by=1))
# Call the network topology analysis function
sft = pickSoftThreshold(datt, powerVector = powers, verbose = 8,networkType="signed")
# run from the line below to the save command
s.th=19 # re-specify according to previous section
adjacency = adjacency(datt, power = s.th,type="signed");
TOM = TOMsimilarity(adjacency,TOMType="signed");
rm(adjacency) #for memory space
dissTOM = 1-TOM
rm(TOM)
# Call the hierarchical clustering function
geneTree = flashClust(as.dist(dissTOM), method = "average")
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Calculate eigengenes
MEList = moduleEigengenes(datt, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
METree = flashClust(as.dist(MEDiss), method = "average");
save(dynamicMods,dynamicColors,MEs,METree,geneTree,file="1stPassModules.RData")
MEDissThres = 0.4 # in the first pass, set this to 0 - no merging (we want to see the module-traits heatmap first, then decide which modules are telling us the same story and better be merged)
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datt, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = flashClust(as.dist(MEDiss), method = "average");
# how many genes in each module?
table(moduleColors)
# Save module colors and labels for use in subsequent parts
save(MEs, geneTree, moduleLabels, moduleColors, file = "networkdata_signed.RData")
# Define numbers of genes and samples
nGenes = ncol(datt); #15526
nGenes
nSamples = nrow(datt); #43
nSamples
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datt, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleGeneCor=cor(MEs,datt)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
moduleTraitCor = cor(MEs, traits_withphysio, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(
Matrix = moduleTraitCor,
xLabels = names(traits_withphysio),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1, 1),
main = paste("Module-trait relationships")
)
library(RColorBrewer)
modLabels=sub("ME","",names(MEs))
ps=signif(moduleTraitPvalue,1)
cors=signif(moduleTraitCor,2)
textMatrix = cors;
# paste(cors, "\n(",ps, ")", sep = "");
textMatrix[ps>0.05]="-"
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(traits_withphysio),
ySymbols = modLabels,
yLabels = modLabels,
colorLabels = FALSE,
colors = colorRampPalette(c("blue","lightblue","white","coral","red"))(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.7,
zlim = c(-0.7,0.7),
main = paste("A.cervicornis Module-Trait correlations"))
ps
moduleTraitPvalue
ps
par(mar = c(6, 8.5, 3, 3));
mct=table(moduleColors)
mct[modLabels]
x=barplot(mct[rev(modLabels)],horiz=T,las=1,xlim=c(0,16000),col=rev(modLabels))
text(mct[rev(modLabels)]+labelShift,y=x,mct[rev(modLabels)],cex=0.9)
labelShift=750 # increase to move module size labels to the right
par(mar = c(6, 8.5, 3, 3));
mct=table(moduleColors)
mct[modLabels]
x=barplot(mct[rev(modLabels)],horiz=T,las=1,xlim=c(0,16000),col=rev(modLabels))
text(mct[rev(modLabels)]+labelShift,y=x,mct[rev(modLabels)],cex=0.9)
# run for each of these statements individually
whichTrait="Initial"
nGenes = ncol(datt);
nSamples = nrow(datt);
selTrait = as.data.frame(traits_withphysio[,whichTrait]);
names(selTrait) = whichTrait
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(signedKME(datt, MEs));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datt, selTrait, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(selTrait), sep="");
names(GSPvalue) = paste("p.GS.", names(selTrait), sep="");
# selecting specific modules to plot (change depending on which trait you're looking at)
moduleCols=c("blue","royalblue", "lightgreen", "grey60", "turquoise", "grey") # for Initial
counter=0
# shows correlations for all modules
for(module in modNames[1:length(modNames)]){
counter=counter+1}
quartz()
par(mfrow=c(3,3))
# shows correlations for significant modules only as specified above
for (module in moduleCols) {
column = match(module, modNames);
moduleGenes = moduleColors==module;
column = match(module, modNames);
moduleGenes = moduleColors==module;
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste(module,"module membership"),
ylab = paste("GS for", whichTrait),
col = "grey50",mgp=c(2.3,1,0))
}
