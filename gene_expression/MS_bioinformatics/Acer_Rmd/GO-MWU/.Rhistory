#need to check normality and variance visually (boxplots of fixed effects only)
qqnorm(resid(AcerCBASS_GLMM))
qqline(resid(AcerCBASS_GLMM))
boxplot(resid(AcerCBASS_GLMM)~Acer_ipam_CBASS$Treatment)
boxplot(resid(AcerCBASS_GLMM)~Acer_ipam_CBASS$CBASS_temp)
lrt(AcerCBASS_GLMM, glmm_AcerCBASS_full)
lrt(Acer_CBASS_GLMM_Tank, glmm_AcerCBASS_full)
# GLMM Acer Full: AIC =  -323.6
# GLMM Acer no Colony: AIC =  -324.1
# no colony is better based on AIC, and lrt p-value is not significant
Anova(AcerCBASS_GLMM, type = "II")
lrt(AcerCBASS_GLMM, glmm_AcerCBASS_full)
lrt(Acer_CBASS_GLMM_Tank, glmm_AcerCBASS_full)
ipam_CBASS_normalized %>%
filter(Species == "Acervicornis") -> Acer_ipam_CBASS
Acer_ipam_CBASS
ipam_tidy_data %>%
dplyr::filter(Treatment_period == "CBASS") %>%
dplyr::select(fvfm, Puck:Date, CBASS_temp, Species) %>%
mutate(fvfm_T1 = fvfm) %>%
dplyr::select(!fvfm) %>%
left_join(preCBASSfvfm, by = c("Puck", "Colony", "Species")) %>%
dplyr::select(!Date.x) %>%
dplyr::select(!Date.y) %>%
filter(fvfm_T0 < 0.75) %>% #there were some weird outliers where the fvfm = 2.00
filter(fvfm_T1 < 0.75) %>%
mutate(CBASS_normalize_fvfm = fvfm_T1/fvfm_T0) %>%
filter(CBASS_normalize_fvfm > 0) %>%
filter(CBASS_normalize_fvfm < 1) %>%
mutate(CBASS_normalize_fvfm = as.factor(CBASS_normalize_fvfm))-> ipam_CBASS_normalized
ipam_CBASS_normalized %>%
mutate(CBASS_temp=as.numeric(CBASS_temp)) %>%
ggplot(., aes(x=CBASS_temp, y = CBASS_normalize_fvfm, color = Treatment)) +
geom_point() +
scale_color_manual(labels=c("Control", "Variable"), values = c( "#60DBDB", "#F54A34")) +
geom_smooth(formula = y ~ x, method = "loess", span = 0.9)  +
facet_wrap(~Species) +
theme_classic() +
labs(x="Temperature (ºC)", y = "Normalized Fv/Fm")
ipam_tidy_data %>%
dplyr::filter(Treatment_period == "CBASS") %>%
dplyr::select(fvfm, Puck:Date, CBASS_temp, Species) %>%
mutate(fvfm_T1 = fvfm) %>%
dplyr::select(!fvfm) %>%
left_join(preCBASSfvfm, by = c("Puck", "Colony", "Species")) %>%
dplyr::select(!Date.x) %>%
dplyr::select(!Date.y) %>%
filter(fvfm_T0 < 0.75) %>% #there were some weird outliers where the fvfm = 2.00
filter(fvfm_T1 < 0.75) %>%
mutate(CBASS_normalize_fvfm = fvfm_T1/fvfm_T0) %>%
filter(CBASS_normalize_fvfm > 0) %>%
filter(CBASS_normalize_fvfm < 1) %>%
mutate(CBASS_temp = as.factor(CBASS_temp))-> ipam_CBASS_normalized
ggplot(ipam_CBASS_normalized, aes(x=CBASS_temp, y = CBASS_normalize_fvfm, fill=Treatment)) +
geom_boxplot() +
facet_wrap(~Species) +
scale_fill_manual(labels=c("Control", "Variable"), values = c( "#60DBDB", "#F54A34")) +
theme_classic()
ipam_CBASS_normalized %>%
mutate(CBASS_temp=as.numeric(CBASS_temp)) %>%
ggplot(., aes(x=CBASS_temp, y = CBASS_normalize_fvfm, color = Treatment)) +
geom_point() +
scale_color_manual(labels=c("Control", "Variable"), values = c( "#60DBDB", "#F54A34")) +
geom_smooth(formula = y ~ x, method = "loess", span = 0.9)  +
facet_wrap(~Species) +
theme_classic() +
labs(x="Temperature (ºC)", y = "Normalized Fv/Fm")
ipam_CBASS_normalized %>%
filter(Species == "Acervicornis") -> Acer_ipam_CBASS
#model 1 = full model
glmm_AcerCBASS_full <- glmmTMB(CBASS_normalize_fvfm ~ Treatment*CBASS_temp + (1|Colony), family=beta_family(link = "logit"), data=Acer_ipam_CBASS)
summary(glmm_AcerCBASS_full)
qqnorm(resid(glmm_AcerCBASS_full))
qqline(resid(glmm_AcerCBASS_full))
boxplot(resid(glmm_AcerCBASS_full)~Acer_ipam_CBASS$Treatment)
boxplot(resid(glmm_AcerCBASS_full)~Acer_ipam_CBASS$CBASS_temp)
boxplot(resid(glmm_AcerCBASS_full)~Acer_ipam_CBASS$Colony)
#model 2
AcerCBASS_GLMM <- glmmTMB::glmmTMB(CBASS_normalize_fvfm ~ Treatment*CBASS_temp, family=beta_family(link = "logit"), data=Acer_ipam_CBASS)
summary(AcerCBASS_GLMM)
#need to check normality and variance visually (boxplots of fixed effects only)
qqnorm(resid(AcerCBASS_GLMM))
qqline(resid(AcerCBASS_GLMM))
boxplot(resid(AcerCBASS_GLMM)~Acer_ipam_CBASS$Treatment)
boxplot(resid(AcerCBASS_GLMM)~Acer_ipam_CBASS$CBASS_temp)
lrt(AcerCBASS_GLMM, glmm_AcerCBASS_full)
lrt(Acer_CBASS_GLMM_Tank, glmm_AcerCBASS_full)
# GLMM Acer Full: AIC =  -323.6
# GLMM Acer no Colony: AIC =  -324.1
# no colony is better based on AIC, and lrt p-value is not significant
lrt(AcerCBASS_GLMM, glmm_AcerCBASS_full)
lrt(Acer_CBASS_GLMM_Tank, glmm_AcerCBASS_full)
lrt(AcerCBASS_GLMM, glmm_AcerCBASS_full)
lrt(Acer_CBASS_GLMM_Tank, glmm_AcerCBASS_full)
summary(AcerCBASS_GLMM)
summary(glmm_AcerCBASS_full)
Anova(AcerCBASS_GLMM, type = "II")
ipam_CBASS_normalized %>%
filter(Species == "Pclivosa") -> Pcli_ipam_CBASS
#model 1 = full model
glmm_PcliCBASS_full <- glmmTMB(CBASS_normalize_fvfm ~ Treatment*CBASS_temp + (1|Colony), family=beta_family(link = "logit"), data=Pcli_ipam_CBASS)
summary(glmm_PcliCBASS_full)
qqnorm(resid(glmm_PcliCBASS_full))
qqline(resid(glmm_PcliCBASS_full))
boxplot(resid(glmm_PcliCBASS_full)~Pcli_ipam_CBASS$Treatment)
boxplot(resid(glmm_PcliCBASS_full)~Pcli_ipam_CBASS$CBASS_temp)
boxplot(resid(glmm_PcliCBASS_full)~Pcli_ipam_CBASS$Colony)
#model 2
PcliCBASS_GLMM <- glmmTMB::glmmTMB(CBASS_normalize_fvfm ~ Treatment*CBASS_temp, family=beta_family(link = "logit"), data=Pcli_ipam_CBASS)
summary(PcliCBASS_GLMM)
#need to check normality and variance visually (boxplots of fixed effects only)
qqnorm(resid(PcliCBASS_GLMM))
qqline(resid(PcliCBASS_GLMM))
boxplot(resid(PcliCBASS_GLMM)~Pcli_ipam_CBASS$Treatment)
boxplot(resid(PcliCBASS_GLMM)~Pcli_ipam_CBASS$CBASS_temp)
lrt(PcliCBASS_GLMM, glmm_PcliCBASS_full)
# GLMM Pcli Full: AIC =  -355.8
# GLMM Pcli no Colony: AIC =  -344.3  , LRT p-value = 0.0002403821
# full model is better based on AIC and p-value
lrt(PcliCBASS_GLMM, glmm_PcliCBASS_full)
Anova(glmm_PcliCBASS_full, type = "II")
library(DESeq2)
library(tidyverse)
library(factoextra)
load("RData_files/initial_fullddsdesigncountsVsdcountsWGCNA.RData")
pca <- prcomp(t(assay(Vsd)))
summary(pca)
fviz_eig(pca)
plotPCA(Vsd, intgroup = c("Treatment"))
plotPCA(Vsd, intgroup = c("Genotype"))
plotPCA(Vsd, intgroup = c("time_point"))
plotPCA(Vsd, intgroup = c("Treatment", "Genotype", "time_point"))
vst_PCAdata <- plotPCA(Vsd, intgroup = c("Treatment", "Genotype", "time_point"), returnData = TRUE)
percentVar <- round(100*attr(vst_PCAdata, "percentVar"))
ggplot(vst_PCAdata, aes(PC1, PC2, color=Treatment, shape=Genotype)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("P. clivosa") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) +
stat_ellipse(aes(PC1, PC2, group=time_point, lty = time_point), type = "norm")
plotPCA(Vsd, intgroup = c("Treatment","time_point"))
vst_nogeno_PCAdata <- plotPCA(Vsd, intgroup = c("Treatment","time_point"), returnData = TRUE)
percentVar <- round(100*attr(vst_nogeno_PCAdata, "percentVar"))
ggplot(vst_nogeno_PCAdata, aes(PC1, PC2, color=group, shape=Treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("A. cervicornis") +
theme_bw() +
stat_ellipse(aes(PC1, PC2, group=group, lty = time_point), type = "norm") +
scale_color_manual(values = c("#00CCCC","#33CCCC", "#FF6633", "#FF3333"))
ggplot(vst_nogeno_PCAdata, aes(PC1, PC2, color=group, shape=Treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("P. clivosa,") +
theme_bw() +
stat_ellipse(aes(PC1, PC2, group=group, lty = time_point), type = "norm") +
scale_color_manual(values = c("#00CCCC","#33CCCC", "#FF6633", "#FF3333"))
ggplot(vst_nogeno_PCAdata, aes(PC1, PC2, color=group, shape=Treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("P. clivosa") +
theme_bw() +
stat_ellipse(aes(PC1, PC2, group=group, lty = time_point), type = "norm") +
scale_color_manual(values = c("#00CCCC","#33CCCC", "#FF6633", "#FF3333"))
ggplot(vst_nogeno_PCAdata, aes(PC1, PC2, color=group)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("P. clivosa") +
theme_bw() +
scale_color_manual(values = c("#00CCCC","#33CCCC", "#FF6633", "#FF3333"))
ggplot(vst_nogeno_PCAdata, aes(PC1, PC2, color=group, shape=Treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
ggtitle("P. clivosa") +
theme_bw() +
stat_ellipse(aes(PC1, PC2, group=group, lty = time_point), type = "norm") +
scale_color_manual(values = c("#00CCCC","#33CCCC", "#FF6633", "#FF3333"))
library(WGCNA)
library(flashClust)
library(ape)
options(stringsAsFactors=FALSE)
allowWGCNAThreads()
load("wgcnaData.RData")
library(WGCNA)
load(file = "RData_files/networkdata_signed.RData") # moduleColors, MEs
allkME =as.data.frame(signedKME(datt, MEs))
library(WGCNA)
library(flashClust)
library(ape)
options(stringsAsFactors=FALSE)
allowWGCNAThreads()
setwd("OneDrive - University of Miami/GitHub/Ch2_temperaturevariability2023/gene_expression/MS_bioinformatics/Acer_Rmd/")
#which.module="turquoise"
which.module="midnightblue"
table(moduleColors==which.module) # how many genes are in it?
load(file = "RData_files/networkdata_signed.RData") # moduleColors, MEs
load(file = "RData_files/wgcnaData.RData") # vsd table
load(file = "RData_files/data4wgcna.RData")
allkME =as.data.frame(signedKME(datt, MEs))
names(allkME)=gsub("kME","",names(allkME))
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
which.module="darkred"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
which.module="pink"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
#which.module="pink"
which.module="cyan"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
#which.module="pink"
#which.module="cyan"
which.module="green"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
#which.module="pink"
#which.module="cyan"
#which.module="green"
which.module="purple"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
#which.module="pink"
#which.module="cyan"
#which.module="green"
#which.module="purple"
which.module="grey"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
#which.module="turquoise"
#which.module="midnightblue"
#which.module="darkred"
#which.module="pink"
#which.module="cyan"
#which.module="green"
#which.module="purple"
#which.module="grey"
which.module="salmon"
inModuleBinary=as.numeric(moduleColors==which.module)
combo=data.frame("gene"=row.names(vsd.wg),"Fish_kME"=allkME[,which.module]*inModuleBinary)
write.csv(combo,file=paste(which.module,".csv",sep=""),row.names=F,quote=F)
gg=read.delim(file="~/OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2geneName.tab",sep="\t")
library(pheatmap)
which.module="turquoise"
top=30 # number of named top-kME genes to plot
datME=MEs
datExpr=datt
modcol=paste("kME",whichModule,sep="")
datME=MEs
datExpr=datt
modcol=paste("kME",which.module,sep="")
sorted=vsd.wg[order(allkME[,modcol],decreasing=T),]
datME=MEs
datExpr=datt
modcol=paste("kME",which.module,sep="")
sorted=vsd.wg[order(allkME[,modcol],decreasing=T),]
modcol=paste("kME",which.module,sep="")
allkME[,modcol]
allkME[modcol]
allkME[modcol,]
sorted=vsd.wg[order(allkME[modcol,],decreasing=T),]
head(sorted)
sorted=vsd.wg[order(allkME[,"modcol"],decreasing=T),] #Warning message:In xtfrm.data.frame(x) : cannot xtfrm data frames
sorted=vsd.wg[order(allkME["modcol"],decreasing=T),] #Warning message:In xtfrm.data.frame(x) : cannot xtfrm data frames
sorted=vsd.wg[order(allkME[modcol,],decreasing=T),] #Warning message:In xtfrm.data.frame(x) : cannot xtfrm data frames
head(sorted)
gnames=c();counts=0;hubs=c()
for(i in 1:length(sorted[,1])) {
if (row.names(sorted)[i] %in% gg[,1]) {
counts=counts+1
gn=gg[gg[,1]==row.names(sorted)[i],2]
gn=paste(gn,row.names(sorted)[i],sep=".")
if (gn %in% gnames) {
gn=paste(gn,counts,sep=".")
}
gnames=append(gnames,gn)
hubs=data.frame(rbind(hubs,sorted[i,]))
if (counts==top) {break}
}
}
row.names(hubs)=gnames
contrasting = colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
pdf(file="heatmap_top30_turquoise.pdf", height=6, width=18)
pheatmap(hubs,scale="row",col=contrasting,border_color=NA,treeheight_col=0,cex=0.9,cluster_rows=F,cluster_cols=F)
dev.off()
allkME =as.data.frame(signedKME(datt, MEs))
hubgenes <- chooseTopHubInEachModule(datt, moduleColors, omitColors = "grey",
power = 2,
type = "signed")
hubgenes <-data.frame(hubgenes)
hubgenes <- tibble::rownames_to_column(hubgenes, "module")
hubgenes
hubgenes %>%
rename("gene" =
hubgenes) %>%
left_join(read.table(file = "~/OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2geneName.tab",
sep = "\t",
quote="", fill=FALSE) %>%
mutate(gene = V1,
annot = V2) %>%
dplyr::select(-V1, -V2), by = "gene") -> hubgenes
library(tidyverse)
hubgenes %>%
rename("gene" =
hubgenes) %>%
left_join(read.table(file = "~/OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2geneName.tab",
sep = "\t",
quote="", fill=FALSE) %>%
mutate(gene = V1,
annot = V2) %>%
dplyr::select(-V1, -V2), by = "gene") -> hubgenes
hubgenes
write.csv(hubgenes, file="hubgenes.csv")
# Edit these to match your data file names:
input="WGCNA/salmon.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="~/OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
#multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="GO-MWU/go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("GO-MWU/gomwu.functions.R")
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="GO-MWU/gomwu_a.pl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="GO-MWU/gomwu_a.pl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
# Edit these to match your data file names:
input="WGCNA/salmon.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="OneDrive - University of Miami/NOAA ERL/stress hardening 2022/gene expression/Acervicornis_annotatedTranscriptome/Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
#multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="GO-MWU/go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("GO-MWU/gomwu.functions.R")
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="GO-MWU/gomwu_a.pl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
input="salmon.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
#multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="GO-MWU/gomwu_a.pl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
View(gomwuStats)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
input="salmon.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
#multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
source("gomwu.functions.R")
setwd("GO-MWU/")
input="salmon.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
#To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Acervicornis_iso2go.tab" # two-column, tab-delimited, one line per gene,
#multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
goDivision="CC" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
goDivision="MF" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
goDivision="BP" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
# Edit these to match your data file names:
input="cyan.csv" # two columns of comma-separated values: gene id, continuous measure of significance.
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs,
#go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes,
#kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
