## Tag-based RNA-seq (Tag-Seq) reads processing pipeline, version November 9, 2023
# Created by Misha Matz (matz@utexas.edu), modified by Michael Studivan (studivanms@gmail.com) for use on the FAU KoKo HPC
# then modified by Allyson DeMerlis for use on the University of Miami HPC "Pegasus"

# put all raw reads into one directory: 1_fastq_rawreads

# they are all in .fastq.gz file format. First need to look at the reads and ensure that there are 4 lines per read (look for sequence headers)

gunzip SampleName.fastq.gz

# look at the reads
head -50 SampleName.fastq
# note that every read has four lines, the ID line starts with @HWI

#------------------------------

# to count the number of reads in all samples
echo "countreads.pl > countreads_raw.txt" > count
launcher_creator.py -j count -n count -q shortq7 -t 6:00:00 -e studivanms@gmail.com
sbatch count.slurm

what is "countreads.pl"

#!/usr/bin/perl

print "

countreads.pl : counts the number of Illumina reads in a bunch of fastq files
argument - glob to fastq files, default \.fastq

";

my $glob="\.fastq";
if ($ARGV[0]) { $glob=$ARGV[0];}

opendir THIS, ".";
my @fqs=grep /$glob/,readdir THIS;
my $f;
my $nrd;
foreach $f(@fqs){
	$nrd=`cat $f | wc -l`;
	$nrd=$nrd/4;
	print "$f\t$nrd\n";
}

#asked ChatGPT to convert to bash

#!/bin/bash

echo "
countreads.sh: counts the number of Illumina reads in a bunch of fastq files
argument - glob to fastq files, default \.fastq
"

glob=".fastq"
if [ ! -z "$1" ]; then
    glob="$1"
fi

fqs=(*$glob)
for f in "${fqs[@]}"; do
    nrd=$(cat "$f" | wc -l)
    nrd=$((nrd / 4))
    echo "$f	$nrd"
done

# Final job script that worked that was submitted on Pegasus

#!/bin/bash
#BSUB -J countrawreads
#BSUB -q general
#BSUB -P and_transcriptomics
#BSUB -n 8
#BSUB -W 120:00
#BSUB -o countrawreads.out
#BSUB -e countrawreads.err
#BSUB -u and128@miami.edu
#BSUB -N

#Purpose: counts the number of Illumina reads in a bunch of fastq files

#specify variables and paths

and="/scratch/projects/and_transcriptomics"

cd "/scratch/projects/and_transcriptomics/Ch2_temperaturevariability2023/1_fastq_rawreads"

output_file="countreads_results.txt"

glob=".fastq.gz"
if [ ! -z "$1" ]; then
    glob="$1"
fi

fqs=(*$glob)
for f in "${fqs[@]}"; do
    nrd=$(cat "$f" | wc -l)
    nrd=$((nrd / 4))
    echo "$f	$nrd" >> "$output_file"
done

echo "Results have been saved to $output_file"

Ok the numbers don't match up at all though, so I think I need to gunzip the file first

#!/bin/bash
#BSUB -J countrawreads
#BSUB -q general
#BSUB -P and_transcriptomics
#BSUB -n 8
#BSUB -W 120:00
#BSUB -o countrawreads.out
#BSUB -e countrawreads.err
#BSUB -u and128@miami.edu
#BSUB -N

#Purpose: counts the number of Illumina reads in a bunch of fastq files

#specify variables and paths

and="/scratch/projects/and_transcriptomics"

cd "/scratch/projects/and_transcriptomics/Ch2_temperaturevariability2023/1_fastq_rawreads"

output_file="countreads_results.txt"

glob=".fastq"
if [ ! -z "$1" ]; then
    glob="$1"
fi

fqs=(*$glob)
for f in "${fqs[@]}"; do
    gunzip -c "$f" > "temp.fastq"  # Decompress the file to a temporary file
    nrd=$(cat "temp.fastq" | wc -l)
    nrd=$((nrd / 4))
    echo "$f	$nrd"
    echo "$f	$nrd" >> "$output_file"  # Append the results to the output file
    rm "temp.fastq"  # Remove the temporary file
done

echo "Results have been saved to $output_file"

#------------------------------

# For the next step, I will be using TrimGalore to cutadapt.

Michael's code:

#------------------------------
## Removing adaptors and low quality reads

conda activate cutadaptenv

echo '#!/bin/bash' > trim.sh
echo 'conda activate cutadaptenv' >> trim.sh
for F in *.fastq; do
echo "tagseq_clipper.pl $F | cutadapt - -a AAAAAAAA -a AGATCGG -q 15 -m 25 -o ${F/.fastq/}.trim" >>trim.sh;
done

# does not work with launcher_creator, consider breaking up script and running multiple jobs
sbatch -o trim.o%j -e trim.e%j --mem=200GB trim.sh

# checking the status of the job
squeue -u mstudiva

# double check you have the same number of files as samples
ll *.trim | wc -l

# did the trimming work?
head -100 SampleName.fastq | grep -E '^[NACGT]+$'
head -100 SampleName.trim | grep -E '^[NACGT]+$'
# the long runs of base A should be gone

# double-check that the rnaseq_clipper did not filter out too many reads by looking at the trim.e####### file
# make sure you're not losing too many reads to duplicates
# rename as a txt file
mv trim.e####### trim.txt

# to save time in case of issues, move the concatenated fastq files to backup directory
mv *.fastq ~/rawReads/

# to count the number of reads in trimmed samples
echo "countreads_trim.pl > countreads_trim.txt" > count_trim
launcher_creator.py -j count_trim -n count_trim -q shortq7 -t 6:00:00 -e studivanms@gmail.com
sbatch count_trim.slurm

#------------------------------

tagseq_clipper.pl

#!/usr/bin/perl

$usage= "

tagseq_clipper.pl  :

Clips 5'-leader off Illumina fastq reads in RNA-seq

Removes duplicated reads sharing the same degenerate header and
the first 20 bases of the sequence (reads containing N bases in this
region are discarded, too)

prints to STDOUT

arguments:
1 : fastq file name
2 : string to define the leading sequence, default '[ATGC]?[ATGC][AC][AT]GGG+|[ATGC]?[ATGC]TGC[AC][AT]GGG+|[ATGC]?[ATGC]GC[AT]TC[ACT][AC][AT]GGG+'

Example:
tagseq_clipper.pl D6.fastq


";

my $fq=shift or die $usage;
my $lead="";
if ($ARGV[0]) { $lead=$ARGV[0];}
else { $lead="[ATGC]?[ATGC][AC][AT][AT][AC][AT][ACT]GGG+|[ATGC]?[ATGC][AC][AT]GGG+|[ATGC]?[ATGC]TGC[AC][AT]GGG+|[ATGC]?[ATGC]GC[AT]TC[ACT][AC][AT]GGG+";}
my $trim=0;
my $name="";
my $name2="";
my $seq="";
my $qua="";
my %seen={};
open INP, $fq or die "cannot open file $fq\n";
my $ll=3;
my $nohead=0;
my $dups=0;
my $ntag=0;
my $tot=0;
my $goods=0;
while (<INP>) {
	if ($ll==3 && $_=~/^(\@.+)$/ ) {
		$tot++;
		$name2=$1;
		if ($seq=~/^($lead)(.+)/) {
			my $start=substr($2,0,20);
			my $idtag=$1.$start;
			if (!$seen{$idtag} and $idtag!~/N/) {
				$seen{$idtag}=1;
				$trim=length($1);
				print "$name\n$2\n+\n",substr($qua,$trim),"\n";
				$goods++;
			}
			elsif ($seen{$idtag}) { $dups++; }
			else { $ntag++; }
		}
		elsif ($tot>1) {
			$nohead++;
		}
		$seq="";
		$ll=0;
		$qua="";
		@sites=();
		$name=$name2;
	}
	elsif ($ll==0){
		chomp;
		$seq=$_;
		$ll=1;
	}
	elsif ($ll==2) {
		chomp;
		$qua=$_;
		$ll=3;
	}
	else { $ll=2;}
}

if ($seq=~/^($lead)(.+)/) {
		my $start=substr($2,0,20);
		my $idtag=$1.$start;
		if (!$seen{$idtag} and $idtag!~/N/) {
				$seen{$idtag}=1;
				$trim=length($1);
				print "$name\n$2\n+\n",substr($qua,$trim),"\n";
				$goods++;
		}
		elsif ($seen{$idtag}) { $dups++; }
		else { $ntag++; }
}
elsif ($tot>1) {
	$nohead++;
}

warn "$fq\ttotal:$tot\tgoods:$goods\tdups:$dups\tnoheader:$nohead\tN.in.header:$ntag\n";


#------------------------------
